# 과제 체크포인트

## 배포 링크

https://front-5th-chapter4-2-advanced.vercel.app/ <br >
https://front-5th-chapter4-2-advanced-yubin-kims-projects-668d47e2.vercel.app/

## 과제 요구사항

- [x] 배포 후 url 제출

- [x] API 호출 최적화(`Promise.all` 이해)

- [x] SearchDialog 불필요한 연산 최적화
- [x] SearchDialog 불필요한 리렌더링 최적화

- [x] 시간표 블록 드래그시 렌더링 최적화
- [x] 시간표 블록 드롭시 렌더링 최적화

## 과제 셀프회고

<!-- 과제에 대한 회고를 작성해주세요 -->

이번 주는 과제가 두 갈래로 나뉘어 진행되었다. 기본 과제는 `Vanilla JavaScript` 기반 프로젝트의 성능 개선이었고, 심화 과제는 `React`에서 불필요한 연산과 렌더링을 줄이는 최적화 작업이었다. 개인적으로 각 과제 모두 한 주차 과제로 나와도 될 만큼의 분량이었기 때문에, 기본 과제를 빠르게 마무리했음에도 불구하고 심화 과제에서 많은 어려움을 겪었다. 특히, 배포 후 실제 사용 환경에서 느껴지는 성능과 로컬 개발 환경에서의 성능 차이가 꽤 크게 나타나 어느 정도 수준으로 개선해야 할지 고민을 많이 했던 거 같다.

### 기술적 성장

<!-- 예시
- 새로 학습한 개념
- 기존 지식의 재발견/심화
- 구현 과정에서의 기술적 도전과 해결
-->

#### 기본과제: 성능 개선 보고서 작성
-  `LCP(최대 콘텐츠 표시 지연), INP(입력 지연), CLS(누적 레이아웃 이동)` 등 핵심 웹 성능 지표의 의미와 기준을 학습하고, Lighthouse 및 PageSpeed Insights를 활용해 성능 병목 구간을 진단하는 방법을 익혔다.
- 단순히 점수를 올리는 것이 아닌, 각 지표가 사용자 경험(UX)에 미치는 영향을 중심으로 원인을 분석하고 개선 항목을 도출했다.
- 외부 리소스(Google Fonts, CookieConsent)와 이미지, JS 스크립트가 성능에 끼치는 영향을 정량적으로 분석하였고, .webp 포맷, defer 처리, lazy loading, DOM fragment 처리 등을 활용해 실질적인 개선 효과를 도출했다.
- 이를 바탕으로 개선 전/후의 수치를 비교하며, 데이터 기반 성능 개선 경험을 처음으로 체계화할 수 있었다.

#### 심화과제: 실제 성능 리팩토링 구현
- React에서 `useMemo`, `useCallback` 등의 Hook을 통해 렌더링 최적화를 시도하며, 불필요한 연산과 렌더링을 줄이는 방법을 실습하였다.
- 성능 병목을 느낀 컴포넌트를 중심으로 렌더링 트리 구조와 상태 흐름을 분석하며, 컴포넌트 분리 및 상태 관리 구조 개선을 고민했다.
- DnD(Drop & Drag) 로직을 전면 수정하면서 렌더링 타이밍과 상태 공유 방식의 차이를 경험하고 개선 방안을 직접 구현했다.
- **밑에 추가적인 코멘트를 남겼습니다.**

### 코드 품질

<!-- 예시
- 특히 만족스러운 구현
- 리팩토링이 필요한 부분
- 코드 설계 관련 고민과 결정
-->

```
src
 ┣ api
 ┃ ┗ lectures.ts
 ┣ components
 ┃ ┣ LectureRow.tsx
 ┃ ┣ LectureTable.tsx
 ┃ ┣ ScheduleTable.tsx
 ┃ ┣ ScheduleTables.tsx
 ┃ ┗ SearchFilters.tsx
 ┣ constants
 ┃ ┗ index.ts
 ┣ context
 ┃ ┣ ScheduleContext.tsx
 ┃ ┗ ScheduleDndProvider.tsx
 ┣ data
 ┃ ┗ dummyScheduleMap.ts
 ┣ dialogs
 ┃ ┗ SearchDialog.tsx
 ┣ types
 ┃ ┗ index.ts
 ┣ utils
 ┃ ┗ utils.ts
 ┣ App.tsx
 ┗ main.tsx
```
- 일정 수준의 렌더링 최적화 이후, 역할 기반 폴더 구조로 프로젝트를 재구성하였다. 컴포넌트 수가 증가함에 따라 `components`, `dialogs`, `context`, `api`, `utils` 등으로 분리해 유지보수성을 높였다.
- 컴포넌트 렌더링 최적화를 위해 `React.memo`, `useMemo`, `useCallback`을 적극적으로 활용하였다. 실측 결과 일부 컴포넌트의 체감 성능은 개선되었지만, 구조적 병목이 존재하는 경우에는 한계가 있었다. 이 과정에서 단순한 메모이제이션보다 구조적 접근의 중요성을 체감하였다.
- API 호출 관련 로직을 분리하며 성능 개선을 시도했으나, 단순 분리만으로는 실질적 성능 개선 효과가 제한적임을 확인했다. 렌더링 타이밍이라든가 API 호출 자체에 개수를 정해놓고 불러온다든지의 방법이 필요할 거 같았다.
- 상태 공유가 많아질수록 컴포넌트 간 의존도가 증가하므로, 이후에는 Zustand나 Jotai 등 얕은 전역 상태로 상태를 분리해 관리하는 방식을 고려하면 좋을 것 같다.
- **밑에 추가적인 코멘트를 남겼습니다.**

### 학습 효과 분석

<!-- 예시
- 가장 큰 배움이 있었던 부분
- 추가 학습이 필요한 영역
- 실무 적용 가능성
-->

- `useMemo`와 `useCallback`을 무분별하게 사용하는 것이 오히려 코드 가독성과 유지보수성을 떨어뜨릴 수 있음을 깨달음. 따라서 렌더링 최적화는 불필요한 계산이 반복되는 경우에만 전략적으로 사용하는 것이 중요하다는 교훈을 얻었다.
- 로컬 환경과 실제 배포 환경 간 성능 차이를 경험하면서, 실제 사용자 환경을 고려한 최적화와 측정 방법(GTM/Profiler 등)의 필요성을 느꼈다.
- 단순한 코드 수준의 최적화보다 컴포넌트 구조 개선과 상태 흐름 정리가 성능에 더 큰 영향을 준다는 점을 직접 경험하면서, 성능 개선은 곧 설계 개선이라는 인식이 생겼다.

### 과제 피드백

<!-- 예시
- 과제에서 모호하거나 애매했던 부분
- 과제에서 좋았던 부분
-->

- 9주차에 비해 기본 과제와 심화 과제의 난이도 및 분량 차이가 컸습니다. 특히 심화 과제는 별도로 한 주차를 배정해도 좋을 만큼 복잡성과 리서치/리팩토링 요구 수준이 높았다고 느꼈습니다.
- 10주 동안 고생 많으셨습니다, 코치님! 제가 개인적인 고민이나 질문들을 PR에 자주 남겼던 거 같은데 그때마다 실질적으로 도움이 되는 조언을 상세히 남겨주셔서 큰 힘이 되었습니다. 특히 이직이나 회사에 대한 고민으로 혼란스럽고 불안했던 시기에, 코치님의 따뜻한 코멘트들이 큰 위로가 되었습니다. 감사해요!


## 리뷰 받고 싶은 내용

- Chakra UI 컴포넌트가 내부적으로 context나 forwardRef를 사용하고 있어서 메모이제이션 효과가 제한적인 경우가 있는데, 이런 상황에서 상위에서 분리 가능한 부분만 memo로 감싸는 게 유효한 전략일지, 혹은 native HTML 태그나 emotion 등으로 대체하는 것도 고려해야 할지 궁금합니다.
- 레거시 코드를 성능 최적화하는 것이 항상 좋은 선택일지 고민이 됩니다.
기존 코드를 리팩토링하며 성능을 개선하는 게 나을지, 아니면 아예 새롭게 다시 작성하는 것이 더 효율적일지 판단이 어려운 경우가 많습니다. 이런 경우, 코치님은 어떤 기준으로 리팩토링과 재작성 중 무엇을 선택하시나요? 비용과 시간의 균형은 어떻게 판단하시는지도 궁금합니다. 그리고, 코드 커버리지나 테스트 유무도 고려하시나요...?
- 성능 최적화 방향을 잡을 때, Profiler 외에 실무에서 어떤 성능 측정 도구나 기준을 가장 신뢰하시는지(예: Web Vitals) 궁금합니다.
